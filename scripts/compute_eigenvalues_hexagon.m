function results = compute_eigenvalues_hexagon(hmax, rmin, rmax, a, b, c, hole_type, j)
  % hmax: size of mesh
  % rmin, rmax: search for eigenvalues between these values
  % a, b, c, hole_type: Determines the type of and the placement of the holes
  % j: Which eigenfunction to plot

  % The candidates in the paper are generated by:
  % compute_eigenvalues_hexagon(0.275/20, 20, 80, 0.18, 0.1, 0.2, 3, 2)
  % compute_eigenvalues_hexagon(0.275/20, 20, 80, 1/22, 9, 6, 1, 2)
  % compute_eigenvalues_hexagon(0.275/20, 10, 80, 0.39, 0.02, 0.1, 3, 2)
  % compute_eigenvalues_hexagon(0.275/20, 20, 80, 1/27, 11, 6, 1, 2)
  % I tried to generate one with hole_type = 2 but couldn't find one at
  % that time.
  
  % Define the geometry of the domain.
  
  % For a polygon, the first row contains 2. The second row contains n,
  % which is the number of line segments in the boundary of the polygon.
  % The next n rows contain the x-coordinates of the starting points of the
  % edges, and the n rows after that contain the y-coordinates of the
  % starting points of the edges.
  
  % Geometry for the hexagon. 
  hexagon = [2, 6, 1, 0.5, -0.5, -1, -0.5, 0.5, 0, cospi(1/6), cospi(1/6), 0, -cospi(1/6), -cospi(1/6)]';
  
  % Geometry for the 6 interior domains, one per column
  interiors = zeros(length(hexagon), 6);
  
  % Geometry of the first interior domain
  if hole_type == 1 % Triangles pointing outwards
      interiors(1:2, :) = repelem([2; 3], 1, 6);
      
      points = [b*a -c*a/sqrt(3); (b + c)*a 0; b*a, c*a/sqrt(3)];
  elseif hole_type == 2 % Triangles pointing inwards
      interiors(1:2, :) = repelem([2; 3], 1, 6);
      
      points = [1 0; cospi(1/3) sinpi(1/3); 0, 0];
      points = points .* [b; b; 1];
      points(3,:) = points(3,:) + 2*sinpi(1/3)*b*[cospi(1/6) sinpi(1/6)];
      points = points + c*[cospi(1/6) sinpi(1/6)];
  elseif hole_type == 3 % Quadrilaterals
      interiors(1:2, :) = repelem([2; 4], 1, 6);
      
      points = [1 0; 1 0; cospi(1/3) sinpi(1/3); cospi(1/3) sinpi(1/3)];
      points = points .* [a + b; a; a; a + b];
      points(2:3,:) = points(2:3,:) + 2*sinpi(1/3)*b*[cospi(1/6) sinpi(1/6)];
      points = points + c*[cospi(1/6) sinpi(1/6)];
  else
      throw(baseException)
  end
  
  % Possibly rotate the hole by -pi/6
  rotate = false;%hole_type == 2;
  if rotate
      M = [cospi(-1/6) -sinpi(-1/6); sinpi(-1/6) cospi(-1/6)];
      points = (M*points')';
  end
  
  interiors(3:3+2*interiors(2,1)-1,1) = points(:);
 
  % The other 5 interior domains are rotated copies of the first one
  for i = 2:6
     n = interiors(2,i);
     theta = (i-1)*pi/3;
     s = sin(theta);
     c = cos(theta);
     interiors(3:3+n-1,i) = interiors(3:3+n-1,1).*c - interiors(3+n:3+2*n-1,1).*s;
     interiors(3+n:3+2*n-1,i) = interiors(3:3+n-1,1).*s + interiors(3+n:3+2*n-1,1).*c;
  end
  
  gd = [hexagon, interiors];
  ns = char('hexagon', 'interior1', 'interior2', 'interior3', 'interior4', 'interior5', 'interior6')';
  sf = 'hexagon-(interior1+interior2+interior3+interior4+interior5+interior6)';
  
  g = decsg(gd,sf,ns);
  
  % Create the PDE model with the above geometry
  
  numberOfPDE = 1;
  pdem = createpde(numberOfPDE);

  % Create a geometry object and append it to the PDE Model
  geometryFromEdges(pdem, g);
  generateMesh(pdem,'hmax', hmax);

  % Dirichlet Boundary conditions
  if hole_type == 1 || hole_type == 2
      applyBoundaryCondition(pdem,'dirichlet','Edge',1:24, 'u', 0);
  else
      applyBoundaryCondition(pdem,'dirichlet','Edge',1:30, 'u', 0);
  end
  specifyCoefficients(pdem,'m',0,'c',1,'a',0,'f',0,'d',1);
  
  r = [rmin rmax];
  results = solvepdeeig(pdem,r);
  
  % Prepare eigenvector for plotting
  u = results.Eigenvectors(:, j);
  
  plot_type = 2;
  if plot_type == 1 % Cut of the eigenfunction depending on value
      v = zeros(length(u), 1);
      cut_off = 2e-3*abs(interpolateSolution(results,[0],[0],j));
      v(:) = 1;
      v(u < 2*cut_off) = 0.75;
      v(u < cut_off) = 0.5;
      v(u < 0) = -0.5;
      v(u < -cut_off) = -0.75;
      v(u < -2*cut_off) = -1;
      
      %u(u > cut_off) = 1;
      %u(u > 0 & u < cut_off) = 0.5;
      %u(u < 0 & u > -cut_off) = -0.5;
      %u(u < -cut_off) = -1;
  elseif plot_type == 2 % Plot sign*log(abs())
      v = sign(u).*log(abs(u));
  else
      v = u;
  end
  
  pl = pdeplot(pdem, 'XYData', v);
  set(gca, 'Visible', 'off');
  set(gca, 'DataAspectRatio', [1 1 1]);
  colorbar off;
  
  results.Eigenvalues
  
  %figure(1);
  %pdeplot(pdem, 'XYData', results.Eigenvectors(:, j));
  %figure(2);
  %pdeplot(pdem, 'XYData', results.Eigenvectors(:, j + 1));
  %figure(3);
  %pdeplot(pdem, 'XYData', results.Eigenvectors(:, j + 2));
  %figure(4);
  %pdeplot(pdem, 'XYData', results.Eigenvectors(:, j + 3));
  
  % To return the plot instead of the PDE results
  %results = pl;
end
